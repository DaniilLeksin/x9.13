__author__ = 'Daniil Leksin'

# NIST-Recommended
# Random Number Generator
# Based on ANSI X9.31
# Using the AES
#
# Let ede*X(Y) represent the AES encryption of Y under the key *X.
# For AES 128-bit key, let *K be a 128 bit key.
# For AES 192-bit key, let *K be a 192 bit key.
# For AES 256-bit key, let *K be a 256 bit key.

# This *K is reserved only for the generation of pseudo random numbers.

# Let V be a 128-bit seed value which is also kept secret, and XOR be the exclusive-or operator.
# Let DT be a date/time vector which is updated on each iteration. I is a intermediate value.
# A vector R is generated as follows (Note for AES implementations DT, I, and R are 128-bits each.):
# I = ede *K(DT)
# R = ede *K(I XOR V) and a new V is generated by V = ede*K(R Xor I).


from aes import AES


def convert(text):
    """
    Function to convert ASCII symbols into long int type.
    :param text:
    :return:
    """
    tdt = ''
    for i in text:
        tdt += hex(ord(i)).rsplit('0x')[1]
    return int(tdt, 16)


def check(cypher_text):
    """
    Function to check the byte count and to convert from long int to hex string
    :param cypher_text:
    :return: hex string
    """
    data = hex(cypher_text).replace('0x', '')
    data = data.replace('L', '')
    if len(data) == 31:
        data = '0' + data
    data = data.decode("hex")
    return data


def save(data):
    """
    Function to save data into file
    :param data:
    :return: None
    """
    open('random_419952.dat', 'wb').write(data)


def hex2bin(hex_string):
    """
    Function to convert hex string to binary string
    :param hex_string:
    :return: binary string
    """
    bin_list = ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
                '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111']
    result_string = ''
    for i in range(len(hex_string)):
        result_string += bin_list[int(hex_string[i], 16)]
    return result_string


def test():
    """
    Function to perform monobit test,
    it calculates the number of '0' and '1' in sequence,
    and save to file stat_419952.txt
    :return: None
    """
    zeros = 0
    ones = 0
    data = open('random_419952.dat', 'rb').read()
    for i in data:
        i = i.encode("hex")
        if len(i) < 2:
            i = '0' + i
        b = hex2bin(i)
        zeros += b.count('0')
        ones += b.count('1')

    open('stat_419952.txt', 'wb').write("Monobit test. The number n1 of 1's in s should satisfy 9654 < n1 < 10346" +
                                        "number of ones: %d\nnumber of zeros: %d\n" % (ones, zeros))


def go_hard():
    """
    Function to generate ANSI X9.31 pseudo random number generator with the 128bit version of AES
    :return: None
    """
    # Initial seed
    V = 0x00000000000000000000000000000001
    # Encryption key
    encryption_key = 0x00000000000000000000000000000010
    # Instance of the AES class
    A = AES(encryption_key)
    data = ''
    # Read the Data \ Time vector from the file 'dt.dat'
    for DT in open('dt.dat', 'rb').read().split('\n'):
        if DT:
            DT = DT.replace('\r', '')
            DT_ = convert(DT)

            # Main block of the algorithm
            I = A.encrypt(DT_)      # Intermediate value
            R = A.encrypt(I ^ V)    # R - generated random value, I ^ V - xor-ing
            V = A.encrypt(R ^ I)    # New V

            R = check(R)
            data += R
    save(data)
    print 'PRNG generation Complete'

# Function: main()
if __name__ == '__main__':
    go_hard()   # Generate randoms
    test()      # Monobit test
